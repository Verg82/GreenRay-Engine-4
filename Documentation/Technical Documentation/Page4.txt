[b]2.4. Собираем "куб".[/b]
1) Для начала создадим новый файл под названием GR_SkyBox.cpp:
Для этого в "дереве" нашего проекта выбираем Source Files и нажимаем на нём правой кнопкой мыши, далее из выпадающего меню выбираем Add->New Item.. Делаем те же действия, что и при создании файла модуля GR_Camera.cpp, не забываем этот файл сохранить в папке Engine_Modules.

Наполняем файл следующим кодом:

[code=cpp]
/*******************************************************************************
// It's Unofficial Version Of The GreenRay Engine v.3.0.0.2
// GR_SkyBox.cpp
// It's The GreenRay SkyBox Geometry Transform Engine Source File.
// Made Specially For Implementing Only SkyBox Geometry And Effects.
*******************************************************************************/
#include <GR_SkyBox.h>

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction For CGRSkyBox Class
//////////////////////////////////////////////////////////////////////////////
CGRSkyBox::CGRSkyBox(LPDIRECT3DDEVICE9 pDevice)
{
  //Присваивание и "передача" указателя Direct3D Device в наш класс
  d_pDevice = pDevice; //To Appropriate Device Pointer To Class
  
  //Подготовка вершинного буфера
  m_pVertexBuffer = NULL; //Prepare Vertex Buffer

  //Подготовка индексного буфера
  m_pIndexBuffer = NULL; //Prepare Index Buffer

  //Подготовка текстур, присваивание массиву текстур значения
  //NULL как видите идёт одной строкой:
  memset(m_pTex,0x00,sizeof(m_pTex)); 
} //EndConstructionDirectives

CGRSkyBox::~CGRSkyBox()
{  
} //EndDestructionDirectives

//------------------------------------------------------------------------------
// Name: CGRSkyBox::Release()
// Desc: 
//------------------------------------------------------------------------------
void CGRSkyBox::Release()
{
  for (UINT I = 0; I < 6; I++) { ReleaseClass(m_pTex[I]); m_TexPath[I] = NULL; } //Free Textures
  ReleaseClass(m_pVertexBuffer); //Free Vertex Buffer
  ReleaseClass(m_pIndexBuffer); //Free Index Buffer
  d_pDevice = NULL; //NULL Device Pointer
} //EndReleaseProcedure

//-----------------------------------------------------------------------------
// Name: CGRSkyBox::SetTextures()
// Desc: Loading And Init Textures
//-----------------------------------------------------------------------------
void CGRSkyBox::SetTextures(TCHAR* _TexBack,TCHAR* _TexLeft,
TCHAR* _TexFront,TCHAR* _TexRight,TCHAR* _TexFloor,TCHAR* _TexCeiling)
{
  m_TexPath[0] = _TexBack;
  m_TexPath[1] = _TexLeft;
  m_TexPath[2] = _TexFront;
  m_TexPath[3] = _TexRight;
  m_TexPath[4] = _TexFloor;
  m_TexPath[5] = _TexCeiling;

  //Create Some Textures
  for (UINT I = 0; I < 6; I++)
  {
    if (FAILED(D3DXCreateTextureFromFileEx(d_pDevice,m_TexPath[I],D3DX_DEFAULT,D3DX_DEFAULT,
    1,0,D3DFMT_UNKNOWN,D3DPOOL_MANAGED,D3DX_DEFAULT,D3DX_DEFAULT,0,NULL,NULL,&m_pTex[I])))
    {
      ShowMessage("GRWorld.cpp: Can't Load SkyBox Texture");
    }
  }
} //EndSetTexturesProcedure

//-----------------------------------------------------------------------------
// Name: CGRSkyBox::CreateBox()
// Desc: Создание "коробки" SkyBox-а с инициализацией вершинного и индексного
// буфера.
//-----------------------------------------------------------------------------
HRESULT CGRSkyBox::CreateBox(float fWidth,float fHeight,float fDepth)
{
  m_pWidth = fWidth;
  m_pHeight = fHeight;
  m_pDepth = fDepth;

  //Массив с описанием 6 сторон куба в данной структуре вершин 
  //описываются координаты вершин в пространстве и текстурные
  //"барицентрические" (Barycentric) TU - TV координаты.
  SKYBOX_VERTEX Vertexes[] =
  {
    //Width   Height   Depth  tu(W) tv(H)
    //Back Wall
    { fWidth, 0.0f,    0.0f, 0.0f, 1.0f, }, //A
    { fWidth, fHeight, 0.0f, 0.0f, 0.0f, }, //B
    { 0.0f,   fHeight, 0.0f, 1.0f, 0.0f, }, //C
    { 0.0f,   0.0f,    0.0f, 1.0f, 1.0f, }, //D
   
    //Left Wall
    { 0.0f, 0.0f,    0.0f,   0.0f, 1.0f, }, //A2
    { 0.0f, fHeight, 0.0f,   0.0f, 0.0f, }, //B2
    { 0.0f, fHeight, fDepth, 1.0f, 0.0f, }, //C2
    { 0.0f, 0.0f,    fDepth, 1.0f, 1.0f, }, //D2
    
    //Front Wall
    { 0.0f,   0.0f,    fDepth, 0.0f, 1.0f, }, //A3
    { 0.0f,   fHeight, fDepth, 0.0f, 0.0f, }, //B3
    { fWidth, fHeight, fDepth, 1.0f, 0.0f, }, //C3
    { fWidth, 0.0f,    fDepth, 1.0f, 1.0f, }, //D3
    
    //Right Wall
    { fWidth, 0.0f,    fDepth, 0.0f, 1.0f, }, //A4  
    { fWidth, fHeight, fDepth, 0.0f, 0.0f, }, //B4
    { fWidth, fHeight, 0.0f,   1.0f, 0.0f, }, //C4
    { fWidth, 0.0f,    0.0f,   1.0f, 1.0f, }, //D4
    
    //Floor    
    { fWidth, 0.0f, 0.0f,   1.0f, 1.0f, }, //A5
    { 0.0f,   0.0f, 0.0f,   0.0f, 1.0f, }, //B5
    { 0.0f,   0.0f, fDepth, 0.0f, 0.0f, }, //C5
    { fWidth, 0.0f, fDepth, 1.0f, 0.0f, }, //D5
     
    //Ceiling
    { fWidth, fHeight, fDepth, 1.0f, 1.0f, }, //A6 
    { 0.0f,   fHeight, fDepth, 0.0f, 1.0f, }, //B6
    { 0.0f,   fHeight, 0.0f,   0.0f, 0.0f, }, //C6
    { fWidth, fHeight, 0.0f,   1.0f, 0.0f, }, //D6
    //  x        y       z     tu(W) tv(H)
  }; //End Vertexes Description

  //Массив индексов содержащий и описывающий 6 сторон куба (12 треугольников)
  const unsigned short Index[] = 
  {
  0,1,2,    2,3,0,
  4,5,6,    6,7,4,
  8,9,10,   10,11,8,
  12,13,14, 14,15,12,
  16,17,18, 18,19,16,
  20,21,22, 22,23,20, 
  }; //End Indexes Description
    
  //Create Vertex Buffer
  //Создание буфера вершин
  if (FAILED(d_pDevice->CreateVertexBuffer(36*sizeof(SKYBOX_VERTEX),0, 
  D3DFVF_SKYBOXVERTEX,D3DPOOL_DEFAULT,&m_pVertexBuffer,NULL))) return E_FAIL;

  //Lock The Vertex Buffer
  //Блокируем вершинный буфер
  VOID* pBV;
  if (FAILED(m_pVertexBuffer->Lock(0,sizeof(Vertexes),(void**)&pBV,0))) return E_FAIL;
  
  //Заполнение вершинного буфера данными
  memcpy(pBV,Vertexes,sizeof(Vertexes)); //Copy Vertex Data To Memory

  //Разблокируем вершинный буфер
  m_pVertexBuffer->Unlock(); //Unlock The Vertex Buffer
    
  //Create Index Buffer
  //Создание индексного буфера, здесь всё происходит 
  //примерно тоже самое, что и при создании вершинного буфера.
  d_pDevice->CreateIndexBuffer(36*sizeof(Index),0,D3DFMT_INDEX16,D3DPOOL_DEFAULT,&m_pIndexBuffer,NULL);
    
  //Lock The Index Buffer
  VOID* pBI;
  m_pIndexBuffer->Lock(0,sizeof(Index),(void**)&pBI,0); 
    
  memcpy(pBI,Index,sizeof(Index)); //Copy Index Data To Memory
      
  m_pIndexBuffer->Unlock(); //Unlock The Index Buffer
 
  return S_OK;
} //EndCreateSkyBoxFunction

//-----------------------------------------------------------------------------
// Name: CGRSkyBox::Render()
// Desc: Rendering The SkyBox Geometry With Textures
//-----------------------------------------------------------------------------
void CGRSkyBox::Render()
{  
  //Устанавливаем параметры рендера и отключаем Z-Буфер
  d_pDevice->SetRenderState(D3DRS_ZENABLE,FALSE);
  d_pDevice->SetRenderState(D3DRS_ZWRITEENABLE,FALSE);
  d_pDevice->SetRenderState(D3DRS_CULLMODE,D3DCULL_CCW);
  d_pDevice->SetRenderState(D3DRS_LIGHTING,FALSE);

  //VU Addr Задаём параметры текстурного сэмплера.
  d_pDevice->SetSamplerState(0,D3DSAMP_ADDRESSU,D3DTADDRESS_CLAMP);
  d_pDevice->SetSamplerState(0,D3DSAMP_ADDRESSV,D3DTADDRESS_CLAMP);

  //Set Texture Mode
  //d_pDevice->SetTextureStageState(0,D3DTSS_COLORARG1,D3DTA_TEXTURE);
  //d_pDevice->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_MODULATE);    
  //d_pDevice->SetTextureStageState(0,D3DTSS_COLOROP,D3DTOP_SELECTARG1);
  d_pDevice->SetSamplerState(0,D3DSAMP_MAGFILTER,D3DTEXF_LINEAR);
  d_pDevice->SetSamplerState(0,D3DSAMP_MINFILTER,D3DTEXF_LINEAR);
  //d_pDevice->SetSamplerState(0,D3DSAMP_MIPFILTER,D3DTEXF_POINT);

  //Set Perspective View For Spherical Show SkyBox In Space (60 Degree) 
  //Установка камеры и "перспективы" FOV - Field Of View (область обзора)
  //в сферическое представление с углом в 60 градусов.
  float Aspect_Ratio = 1.1f;
  D3DXMATRIXA16 Mat_Proj;
  //FLOAT fAspectRatio = (float)m_d3dsdBackBuffer.Width/(float)m_d3dsdBackBuffer.Height;
  D3DXMatrixPerspectiveFovLH(&Mat_Proj,/*D3DX_PI/4*/D3DXToRadian(60.0f),Aspect_Ratio,1.0f,1000.0f);
  d_pDevice->SetTransform(D3DTS_PROJECTION,&Mat_Proj); 

  //Translation Matrices For The SkyBox Object
  //Устанавливаем размеры, позицию в центр, и привязываем SkyBox к камере,
  //чтобы SkyBox как бы двигался вместе с игроком и сам игрок не "приближался" 
  //к граням SkyBox в игровом пространстве.
  D3DXMATRIXA16 Mat_Trans,Mat_Rotate,Mat_Pos,Mat_Centered; 
  //                                        W           H           D
  D3DXMatrixTranslation(&Mat_Centered,-m_pWidth/2,-m_pHeight/2,-m_pDepth/2); 
  D3DXMatrixRotationYawPitchRoll(&Mat_Rotate,D3DX_PI,0.0f,0.0f);
  D3DXMatrixTranslation(&Mat_Pos,gr_Camera->Pos().x,gr_Camera->Pos().y,gr_Camera->Pos().z);
  Mat_Trans = (Mat_Centered*Mat_Rotate)*Mat_Pos; //Multiply Matrices
  d_pDevice->SetTransform(D3DTS_WORLD,&Mat_Trans); //Transform Object Position In Space

  //Draw The SkyBox Here
  //Set Vertex And Index Buffers To Render
  //Ну а здесь уже собственно происходит отрисовка самих граней (полигонов) 
  //SkyBox-куба и наложение текстур..
  d_pDevice->SetTexture(0,NULL);
 
  //Устанавливаем в устройстве текущий вершинный буфер
  d_pDevice->SetStreamSource(0,m_pVertexBuffer,0,sizeof(SKYBOX_VERTEX));
  //Устанавливаем подготовленный ранее FVF наших вершин D3DFVF_SKYBOXVERTEX)
  d_pDevice->SetFVF(D3DFVF_SKYBOXVERTEX); 
  //Устанавливаем индексы из ранее подготовленного индексного буфера:
  d_pDevice->SetIndices(m_pIndexBuffer);
  
  //Output For Created Objects
  //Рендеринг "стенок" куба и  текстур. Вывод примитивов 
  //посредством индексного буфера осуществляется методом DrawIndexedPrimitive

  //Render BackWall
  if (m_pTex[0] != NULL) d_pDevice->SetTexture(0,m_pTex[0]);
  d_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 0, 0, 4, 0, 2 );
  
  //Render LeftWall
  if (m_pTex[1] != NULL) d_pDevice->SetTexture(0,m_pTex[1]);
  d_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 4, 0, 4, 0, 2 ); //Offset To 4 Base Vertex Index 

  //Render FrontWall
  if (m_pTex[2] != NULL) d_pDevice->SetTexture(0,m_pTex[2]);
  d_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 8, 0, 4, 0, 2 ); //Offset To 8 Base Vertex Index 

  //Render RightWall
  if (m_pTex[3] != NULL) d_pDevice->SetTexture(0,m_pTex[3]);
  d_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 12, 0, 4, 0, 2 ); //Offset To 12 Base Vertex Index 

  //Render Floor
  if (m_pTex[4] != NULL) d_pDevice->SetTexture(0,m_pTex[4]);
  d_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 16, 0, 4, 0, 2 ); //Offset To 16 Base Vertex Index

  //Render Ceiling
  if (m_pTex[5] != NULL) d_pDevice->SetTexture(0,m_pTex[5]);
  d_pDevice->DrawIndexedPrimitive(D3DPT_TRIANGLELIST, 20, 0, 4, 0, 2 ); //Offset To 20 Base Vertex Index

  //Здесь уже возвращаем исходные параметры и активируем Z-Buffer, это необходимо
  //для устранения влияния параметров SkyBox на отрисовку последующих
  //элементов сцены которые будут рендериться после самого SkyBox-а в дальнейшем..
  d_pDevice->SetRenderState(D3DRS_ZENABLE,TRUE);
  d_pDevice->SetRenderState(D3DRS_ZWRITEENABLE,TRUE);
  
  //VU Addr Возвращаем исходные параметры для отрисовки текстур,
  //так называемые текстурные "сэмплеры" и устанавливаем их в режим 
  //"обёртки" - WRAP, если этого не сделать, то модель или другая геометрия
  //игрового "мира" имеющая текстуры будет рендериться некорректно, т.е 
  //изображение текстуры будет как бы растягиваться от краёв к центру, иными словами
  //будет сказываться влияние текстурного состояния CLAMP которое мы устанавливали
  //ранее для отрисовки SkyBox..
  d_pDevice->SetSamplerState(0,D3DSAMP_ADDRESSU,D3DTADDRESS_WRAP);
  d_pDevice->SetSamplerState(0,D3DSAMP_ADDRESSV,D3DTADDRESS_WRAP);
} //EndRenderProcedure

//-----------------------------------------------------------------------------

[/code]

2) Создаем файл GR_SkyBox.h:
Для этого также в "дереве" проекта выбираем Header Files, и не забываем сохранить этот файл туда же в папку Engine_Modules и наполняем этот файл следующим кодом:

[code=cpp]
/*******************************************************************************
// It's Unofficial Version Of The GreenRay Engine v.3.0.0.2
// GR_SkyBox.h: Interface For The SkyBox Geometry Implementation Class.
// It's The GreenRay SkyBox Geometry Transform Engine.
// Made Specially For Implementing Only SkyBox Geometry And Effects.
*******************************************************************************/
#include <GR_Engine.h>
#include <GR_Methods.h>
#include <GR_Camera.h>

////////////////////////////////////////////////////////////////////////////////
// Classes Used By This Header
////////////////////////////////////////////////////////////////////////////////
//class CGRSkyBox;

//-----------------------------------------------------------------------------
// Name: CGRSkyBox
// Desc: The Box Class
//-----------------------------------------------------------------------------
#if !defined(AFX_SKYBOX_H__)
#define AFX_SKYBOX_H__

//Константа FVF содержащая формат и структуру вершин 
#define D3DFVF_SKYBOXVERTEX (D3DFVF_XYZ|D3DFVF_TEX1|D3DFVF_TEXCOORDSIZE3(0)) //Vertex Format

class CGRSkyBox
{
public:
   /*Public Directives*/
  //SkyBox Vertex, Normals, Texures Positions
  //Структура содержащая координаты вершин, нормали,
  //цвет и текстурные координаты.
  struct SKYBOX_VERTEX
  {
    FLOAT x,y,z;    //Coordinates
    FLOAT nx,ny,nz; //Normals
    DWORD _Color;   //Vertex Color
    FLOAT tu,tv;    //Textures
  }; //End SkyBox Vertex Formats

  CGRSkyBox(LPDIRECT3DDEVICE9 pDevice);
  virtual ~CGRSkyBox();
  void Release();
  void SetTextures(TCHAR* _TexBack,TCHAR* _TexLeft,TCHAR* _TexFront,
  TCHAR* _TexRight,TCHAR* _TexFloor,TCHAR* _TexCeiling);
  HRESULT CreateBox(float fWidth,float fHeight,float fDepth);
  void Render();
protected:
  /*Protected Directives*/
  LPDIRECT3DDEVICE9 d_pDevice; //Pointer On Direct3D Device Interface
  IDirect3DVertexBuffer9* m_pVertexBuffer; //The Vertex Buffer
  IDirect3DIndexBuffer9* m_pIndexBuffer; //The Index Buffer
  IDirect3DTexture9* m_pTex[6]; //Variable Keep Same Textures
  TCHAR* m_TexPath[6]; //Variable Keep Texture Path
  float m_pWidth,m_pHeight,m_pDepth; //Variables Keep SkyBox WHD Size
};
#endif //!defined(AFX_SKYBOX_H__)

[/code]

3) Если заметите в разделе include я использую #include <GR_Methods.h>
В этом модуле содержатся различные вспомогательные процедуры и функции которые вызываются в движке это различные таймеры, диалоговые окна и др. Создаём и его - для этого в "дереве" нашего проекта выбираем Source Files и нажимаем на нём правой кнопкой мыши, далее из выпадающего меню выбираем Add->New Item.. и сохраняем его под именем GR_Methods.cpp в папку Engine_Modules.
Код файла модуля будет следующим:

[code=cpp]
/******************************************************************************
// It's Unofficial Version Of The GreenRay Engine v.3.0.0.2
// GR_Methods.cpp
// It's The GreenRay Direct3D Useful Control Interfaces Engine Source File.
// Made Specially For Implementing Useful Engine System Manipulations Parameters.
******************************************************************************/
#include <GR_Methods.h>

//-----------------------------------------------------------------------------
// Name: ShowMessage()
// Desc: 
//-----------------------------------------------------------------------------
void ShowMessage(LPCSTR Mes_String)
{
  MessageBoxA(NULL,Mes_String,"GreenRay Engine",MB_SYSTEMMODAL|MB_ICONERROR);
} //EndShowMessageProcedure

///////////////////////////////////////////////////////////////////////////////
// Construction/Destruction For CGRDeltaTimer Class
///////////////////////////////////////////////////////////////////////////////
CGRDeltaTimer::CGRDeltaTimer()
{
} //EndConstructionDirectives

CGRDeltaTimer::~CGRDeltaTimer()
{ 
} //EndDestructionDirectives

//-----------------------------------------------------------------------------
// Name: CGRDeltaTimer::UpdateTimer()
// Desc: Execute Each Frame To Establish Time Base
//-----------------------------------------------------------------------------
void CGRDeltaTimer::UpdateTimer()
{
  CurrentTime = timeGetTime();
  DeltaTime = (float)((CurrentTime-LastTime)*0.001f);
  LastTime = CurrentTime;
} //EndUpdateTimerProcedure

//-----------------------------------------------------------------------------
// Name: CGRDeltaTimer::GetTime()
// Desc:
//-----------------------------------------------------------------------------
float CGRDeltaTimer::GetTime()
{
  return DeltaTime;
} //EndGetTimeFunction

///////////////////////////////////////////////////////////////////////////////
// Construction/Destruction For CGRTimer Class
///////////////////////////////////////////////////////////////////////////////
CGRTimer::CGRTimer()
{
  m_bUsingQPF         = false;
  m_bTimerStopped     = true;
  m_llQPFTicksPerSec  = 0;

  m_llStopTime        = 0;
  m_llLastElapsedTime = 0;
  m_llBaseTime        = 0;

 //Use QueryPerformanceFrequency() To Get Frequency Of Timer.  
 LARGE_INTEGER qwTicksPerSec;
 m_bUsingQPF = (bool)(QueryPerformanceFrequency(&qwTicksPerSec) != 0);
 m_llQPFTicksPerSec = qwTicksPerSec.QuadPart;
} //EndConstructionDirectives

CGRTimer::~CGRTimer()
{ 
} //EndDestructionDirectives

//-----------------------------------------------------------------------------
// Name: CGRTimer::Reset()
// Desc: 
//-----------------------------------------------------------------------------
void CGRTimer::Reset()
{
  if (!m_bUsingQPF) return;

  //Get Either The Current Time Or The Stop Time
  LARGE_INTEGER qwTime;
  if (m_llStopTime != 0) qwTime.QuadPart = m_llStopTime;
  else QueryPerformanceCounter(&qwTime);

  m_llBaseTime = qwTime.QuadPart;
  m_llLastElapsedTime = qwTime.QuadPart;
  m_llStopTime = 0;
  m_bTimerStopped = FALSE;
} //EndResetProcedure

//-----------------------------------------------------------------------------
// Name: CGRTimer::Start()
// Desc: 
//-----------------------------------------------------------------------------
void CGRTimer::Start()
{
  if (!m_bUsingQPF) return;

  //Get The Current Time
  LARGE_INTEGER qwTime;
  QueryPerformanceCounter(&qwTime);

  if (m_bTimerStopped) m_llBaseTime+= qwTime.QuadPart-m_llStopTime;
  m_llStopTime = 0;
  m_llLastElapsedTime = qwTime.QuadPart;
  m_bTimerStopped = FALSE;
} //EndStartProcedure

//-----------------------------------------------------------------------------
// Name: CGRTimer::Stop()
// Desc: 
//-----------------------------------------------------------------------------
void CGRTimer::Stop()
{
  if (!m_bUsingQPF) return;

  if (!m_bTimerStopped)
  {
    //Get Either The Current Time Or The Stop Time
    LARGE_INTEGER qwTime;
    if (m_llStopTime != 0) qwTime.QuadPart = m_llStopTime;
    else QueryPerformanceCounter(&qwTime);

    m_llStopTime = qwTime.QuadPart;
    m_llLastElapsedTime = qwTime.QuadPart;
    m_bTimerStopped = TRUE;
  }
} //EndStopProcedure

//-----------------------------------------------------------------------------
// Name: CGRTimer::Advance()
// Desc: 
//-----------------------------------------------------------------------------
void CGRTimer::Advance()
{
  if (!m_bUsingQPF) return;
  m_llStopTime+= m_llQPFTicksPerSec/10;
} //EndAdvanceProcedure

//-----------------------------------------------------------------------------
// Name: CGRTimer::GetAbsoluteTime()
// Desc: 
//-----------------------------------------------------------------------------
double CGRTimer::GetAbsoluteTime()
{
  if (!m_bUsingQPF) return -1.0;

  //Get Either The Current Time Or The Stop Time
  LARGE_INTEGER qwTime;
  if (m_llStopTime != 0) qwTime.QuadPart = m_llStopTime;
  else QueryPerformanceCounter(&qwTime);

  double fTime = qwTime.QuadPart/(double) m_llQPFTicksPerSec;
  return fTime;
} //EndGetAbsoluteTimeFunction

//-----------------------------------------------------------------------------
// Name: CGRTimer::GetTime()
// Desc: 
//-----------------------------------------------------------------------------
double CGRTimer::GetTime()
{
  if (!m_bUsingQPF) return -1.0;

  //Get Either The Current Time Or The Stop Time
  LARGE_INTEGER qwTime;
  if (m_llStopTime != 0) qwTime.QuadPart = m_llStopTime;
  else QueryPerformanceCounter(&qwTime);

  double fAppTime = (double)(qwTime.QuadPart-m_llBaseTime)/(double)m_llQPFTicksPerSec;
  return fAppTime;
} //EndGetTimeFunction

//-----------------------------------------------------------------------------
// Name: CGRTimer::GetElapsedTime()
// Desc: 
//-----------------------------------------------------------------------------
double CGRTimer::GetElapsedTime()
{
  if (!m_bUsingQPF) return -1.0;

  //Get Either The Current Time Or The Stop Time
  LARGE_INTEGER qwTime;
  if (m_llStopTime != 0) qwTime.QuadPart = m_llStopTime;
  else QueryPerformanceCounter(&qwTime);

  double fElapsedTime = (double)(qwTime.QuadPart-m_llLastElapsedTime)/(double)m_llQPFTicksPerSec;
  m_llLastElapsedTime = qwTime.QuadPart;

  return fElapsedTime;
} //EndGetElapsedTimeFunction

//-----------------------------------------------------------------------------
// Name: CGRTimer::IsStopped()
// Desc: 
//-----------------------------------------------------------------------------
bool CGRTimer::IsStopped()
{
  return m_bTimerStopped;
} //EndIsStoppedFunction

[/code]

4) Также создаём и файл GR_Methods.h выбрав для этого из "дерева" проекта Header Files, и сохранив в папку Engine_Modules.
Код модуля:

[code=cpp]
/******************************************************************************
// It's Unofficial Version Of The GreenRay Engine v.3.0.0.2
// GR_Methods.h
// It's The GreenRay Direct3D Useful Control Interfaces Engine Header File.
// Made Specially For Implementing Useful Engine System Manipulations Parameters.
******************************************************************************/
#include <GR_Engine.h>

////////////////////////////////////////////////////////////////////////////////
// Directives For Release Classes
////////////////////////////////////////////////////////////////////////////////
#define ReleaseClass(_Ptr) { if (_Ptr) { (_Ptr)->Release(); (_Ptr) = NULL; } }
//Directive For Delete Classes
#define DeleteClass(_Ptr) { if (_Ptr) { delete(_Ptr); (_Ptr) = NULL; } }
//Directive For Delete Arrays
#define DeleteArray(_Ptr) { if (_Ptr) { delete[](_Ptr); (_Ptr) = NULL; } }

////////////////////////////////////////////////////////////////////////////////
// Exporting Procedures And Functions
////////////////////////////////////////////////////////////////////////////////
void ShowMessage(LPCSTR Mes_String);

////////////////////////////////////////////////////////////////////////////////
// Classes Used By This Header
////////////////////////////////////////////////////////////////////////////////
//class CGRFPSCounter;
//class CGRDeltaTimer;
//class CGRTimer;

//-----------------------------------------------------------------------------
// Name: Struct CGRDeltaTimer
// Desc:
//-----------------------------------------------------------------------------
#if !defined(AFX_DELTATIMER_H__)
#define AFX_DELTATIMER_H__

class CGRDeltaTimer
{ 
public:
  /*Public Directives*/
  CGRDeltaTimer();
  virtual ~CGRDeltaTimer();
  void UpdateTimer();
  float GetTime();
private:
  /*Private Directives*/
  DWORD CurrentTime; //Current Timer Value
  DWORD LastTime;    //Previous Timer Value
  float DeltaTime;   //Time Elapsed Since Last Frame
};
#endif //!defined(AFX_DELTATIMER_H__)

//-----------------------------------------------------------------------------
// Name: Struct CGRTimer
// Desc:
//-----------------------------------------------------------------------------
#if !defined(AFX_TIMER_H__)
#define AFX_TIMER_H__

class CGRTimer
{ 
public:
  /*Public Directives*/  
  CGRTimer();
  virtual ~CGRTimer();
  
  void Reset(); //Resets The Timer
  void Start(); //Starts The Timer
  void Stop(); //Stop (Or Pause) The Timer
  void Advance(); //Advance The Timer By 0.1 Seconds
  double GetAbsoluteTime(); //Get The Absolute System Time
  double GetTime(); //Get The Current Time
  double GetElapsedTime(); //Get The Time That Elapsed Between GetElapsedTime() Calls
  bool IsStopped(); //Returns True If Timer Stopped
private:
  /*Private Directives*/
protected:
  /*Protected Directives*/
  bool m_bUsingQPF;
  bool m_bTimerStopped;
  LONGLONG m_llQPFTicksPerSec;

  LONGLONG m_llStopTime;
  LONGLONG m_llLastElapsedTime;
  LONGLONG m_llBaseTime;
};
#endif //!defined(AFX_TIMER_H__)

////////////////////////////////////////////////////////////////////////////////
// Global Variables Or Constants
////////////////////////////////////////////////////////////////////////////////
extern CGRDeltaTimer* gr_Timer; //GreenRay Timer Interface Class

[/code]

[mergetime]1246852410[/mergetime]
Ну вот теперь почти всё готово. Теперь разберём некоторые участки кода в модуле SkyBox.cpp:

[code=cpp]
...
  if (FAILED(d_pDevice->CreateVertexBuffer(36*sizeof(SKYBOX_VERTEX),0, 
  D3DFVF_SKYBOXVERTEX,D3DPOOL_DEFAULT,&m_pVertexBuffer,NULL))) return E_FAIL;
...
[/code]

Здесь происходит создание вершинного буфера, он служит для
хранения набора вершин объекта и представляет из себя сплошной
блок памяти, также позволяет вполне компактно хранить и обрабатывать
информацию о вершинах, в качестве параметров здесь указывается формат
вершин (структура хранящая данные о координатах, цвете и нормалях вершин, а
также координаты текстур и многое другое, иными словами называемая ещё 
как FVF (Flexible Vertex Format)) и размер буфера с параметрами размещения 
буфера в памяти.
Как мы видим, для указания формата вершин используется константа 
D3DFVF_SKYBOXVERTEX объявленная в модуле GR_SkyBox.h.

Для получения доступа к данным буфера используется метод Lock интерфейса
m_pVertexBuffer, здесь копируются в адрес Vertexes подготовленные 
описания наших вершин

[code=cpp]
...
  VOID* pBV;
  if (FAILED(m_pVertexBuffer->Lock(0,sizeof(Vertexes),(void**)&pBV,0))) return E_FAIL;
...

[/code]

После заполнения вершинного буфера данными необходимо вызвать метод Unlock,
если этого не сделать, то отрисовка SkyBox происходить не будет, 
да это может вызвать и ошибку работы движка, т.к сам буфер мы изначально 
перевели в заблокированное состояние, поэтому после всех манипуляций его 
необходимо разблокировать:

[code=cpp]
...
  m_pVertexBuffer->Unlock(); //Unlock The Vertex Buffer
...
[/code]

Создание индексного буфера

[code=cpp]
...
  d_pDevice->CreateIndexBuffer(36*sizeof(Index),0,D3DFMT_INDEX16,D3DPOOL_DEFAULT,&m_pIndexBuffer,NULL);
...
[/code]

[b]Примечание![/b] Вообще можно было бы обойтись созданием только лишь вершинным
буфером, но как оказывается на практике данный способ может приводить
к некоторым трудностям при работе только лишь с вершинами, оказывается,
что это очень неэкономичный способ, т.к приходится дублировать эти вершины в 
вершинном буфере, и применяется для создания лишь самой простейшей геометрии,
хотя наш "скайбокс" и не обладает сверхнавороченной геометрией, всё же лучше использовать индексный режим вывода геометрии, т.к данный способ позволяет использовать для описания треугольников не сами вершины, а их индексы (порядковые номера в вершинном буфере). Это позволяет не только не дублировать вершинные данные, но и экономить память (целочисленные индексы занимают намного меньше места, чем вершинные).

Далее разберём код в рендере самого SkyBox:

[code=cpp]
...
  d_pDevice->SetSamplerState(0,D3DSAMP_ADDRESSU,D3DTADDRESS_CLAMP);
  d_pDevice->SetSamplerState(0,D3DSAMP_ADDRESSV,D3DTADDRESS_CLAMP);
...
[/code]

Тут задаются параметры текстурного сэмплера, здесь кроется 
ключевой момент в отрисовке и рендеринга текстур самого SkyBox-а.
Режим "сэмплера" CLAMP обеспечивает "затирание" стыков в углах и граней SkyBox, если этого не сделать, то сразу будут бросаться в глаза ярко выраженные линии стыков по углам, от чего вся иллюзия целостности и объемности пространства полностью сойдет на нет.. Но для того, чтобы добиться нормального результата работы данного 
режима "сэмплирования", каждая текстура кубической карты должна быть строго одинакового размера, если допустим у вас размер текстуры кубической карты 256x256 то и размер всех остальных текстур должен быть таким же, иначе может получиться эффект "сползания" текстуры вбок, и как результат некорректное и некрасивое отображение и отрисовка.. Вообще если заметить то стыки на границах "скайбокса" можно было наблюдать достаточно во многих старых играх, я встречал даже и в более новых..

5) В конце не забудьте положить скачанные текстуры SkyBox-а в папку, которая
создаётся после компиляции проекта и называется "Debug" в ней обычно создаётся и хранится сам скомпилированный *.exe-файл проекта GRDebugger.exe, а также файлы объектов *.obj которые создаются в результате компилирования модулей *.cpp и *.h самого GRE.  Эти файлы должны лежать по пути:
 
[color=darkblue]../GreenRay/GRDebugger/Debug/Textures/SkyBox/GrandCanyon/[/color]

Название конечной папки может называться и по другому на ваше усмотрение, в нашем
случае она называется GrandCanyon, в ней должны лежать файлы с именами соответствующими сторонам SkyBox-куба это: xneg.png, xpos.png, yneg.png, ypos.png, zneg.png, zpos.png, т.е всего 6 файлов, форматы файлов могут быть и другими такие как Jpg, Bmp и др. Этот набор файлов необходим для формирования так называемой кубической карты "CubeMap" далее эти текстуры накладываются на внутренние грани самого SkyBox-куба, в определённом порядке в результате чего формируется эффект окружения и 3-х мерное представление какого-либо помещения, мира, ландшафта, космоса и планет. Эти текстуры можно получить или сделать в специализированных программах, или они фотографируются специализированным оборудованием и фотокамерами в определённой проекции, наиболее распространённый метод для 
фотографирования это кубические проекции, снимаются в шести взаимно перпендикулярных направлениях (включая верх и низ), и представляются в виде крестообразной развёртки:

[IMG]http://s2.ipicture.ru/uploads/20130522/YvxINYTW.jpg[/IMG]

[b]Примечание! [/b]Не забудьте, если у вас папка будет иметь другое имя и путь,
то необходимо этот путь изменить и в коде движка, иначе текстуры загружаться не 
будут, что приведёт к ошибке и закрытию приложения GRE.
Посмотрим на участок кода в модуле GR_Engine.cpp где происходит создание класса SkyBox:

[code=cpp]
...
  //Create SkyBox Class
  gr_SkyBox = new CGRSkyBox(m_pDevice); //Construct A CGRSkyBox Class  
  gr_SkyBox->CreateBox(100.0f,100.0f,100.0f); //Create Our SkyBox Model With Size WHD
  gr_SkyBox->SetTextures(TEXT("\Textures\\SkyBox\\GrandCanyon\\zneg.png"),
                     TEXT("\Textures\\SkyBox\\GrandCanyon\\xneg.png"),
             TEXT("\Textures\\SkyBox\\GrandCanyon\\zpos.png"),
             TEXT("\Textures\\SkyBox\\GrandCanyon\\xpos.png"),
             TEXT("\Textures\\SkyBox\\GrandCanyon\\yneg.png"),
             TEXT("\Textures\\SkyBox\\GrandCanyon\\ypos.png"));
...
[/code]

Здесь создаётся класс "Скайбокса", указываются его размеры в данном случае 100, ну
и соответственно пути к нашим CubeMap-текстурам.

[b]Примечание! [/b]Текстуры CubeMap для движка или другие дополнительные текстуры SkyBox можно взять отсюда: www.codemonsters.de/home/content.php?show=cubemaps

[b]2.5. Заключение.[/b]
Итак в итоге после компиляции проекта должно получиться как на рисунке представленном ниже:

[IMG]http://s2.ipicture.ru/uploads/20130522/t7aXjwyW.jpg[/IMG]

Или ещё вот такой вариант загрузки SkyBox:

[IMG]http://s2.ipicture.ru/uploads/20130522/kWrwa8TK.jpg[/IMG]

Также рекомендуется проверить как работает наша игровая камера, если всё в порядке и камера подключилась нормально то мы сможем осмотреться вокруг, вверх и вниз, ну а если при движении мыши ничего не происходит значит устройства ввода не работают, либо неправильно были переданы какие-либо параметры, либо не произошла инициализация библиотеки DirectInput. 

В следующих статьях мы будем подключать физический движок - PhysX, загрузим небольшой примитивненький уровень, поработаем над его освещением, и научим нашего игрока не "проваливаться" сквозь стены..

До новых встреч! Keep smile! Пока! :)

_________________________________________________________________________
[b]© Digital Dreams Development Inc., 2009 [/b]
(С) GR-Engine Technical Documentation.
при поддержке © Polarity Soft Engine Inc.  
Любая публикация изложенного материала только с разрешения автора.